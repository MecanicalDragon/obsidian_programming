A coroutine is an instance of *suspendable computation*. It is conceptually similar to a thread, in the sense that it accepts a block of code to run concurrently with the rest of the code. However, a coroutine is not bound to any particular thread; it may suspend its execution in one thread and resume in another one. To make this possible, every new coroutine, as a suspendable function, can only be launched in a specific scope that manages its lifecycle - a CoroutineScope. Its instance can be created with the CoroutineScope() or the MainScope() factory functions, and all coroutine builders are declared as extensions of it.

All coroutine builders belong to a particular scope that can be accessed in every builder with this keyword. All coroutine builders return a reference to the coroutine as a Job object, which can be used to manage coroutine manually (wait for its completion with join() function, for example). Difference between launch and async builders – launch returns Job, async – `Deferred<out T>` : Job

*runBlocking* is another coroutine builder that bridges the non-coroutine world of a regular function and the code with coroutines. The name of runBlocking means that the thread that runs it gets blocked for the duration of the call, until all the coroutines inside it complete their execution. runBlocking must never be used in coroutines – it is only a bridge to a blocking world; its analog among the coroutines - coroutineScope builder. While the runBlocking builder blocks the current thread until coroutine’s completion, coroutineScope just suspends the caller coroutine, releasing the underlying thread for other usages. Because of that difference, runBlocking is a regular function and coroutineScope is a suspendable function.

Coroutines always execute in some context represented by a variable of the CoroutineContext type. The coroutine context is a set of various elements; the main elements are the Job and the CoroutineDispatcher. When a coroutine is launched in the CoroutineScope of another coroutine, it inherits its context, and the Job of the new coroutine becomes a child of the parent coroutine's Job. When the parent coroutine is canceled, all its children are recursively canceled either.

When compiler runs a suspended function it creates a StateMachine that tracks execution and keeps metainformation of this function. When function is suspended, it provides a Continuation, that is passed as an additional argument to the StateMachine of called function. Continuation is a function state stored in the object. Each continuation keeps the place in the code where the function was suspended as a pointer to a label in the code.Furthermore, as fields it keeps the function's local variables and parameters, and the reference to the continuation of the parent function. As a result, all these continuations form a call stack that is conveyed among functions as an argument and used when a suspended function resumes, or a resumed function completes.

CoroutineDispatcher is just a wrapper over the predefined and preconfigured thread pool that executes coroutines. It determines what thread or threads particular coroutine uses for its execution. The coroutine dispatcher can delegate coroutine execution to a specific thread, dispatch it to a thread pool, or let it run undelegated.

https://habr.com/ru/articles/659699/
