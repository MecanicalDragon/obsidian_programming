Попробуем найти значение выражения `14^27 mod 55`.  Само по себе `14^27` - сложное вычисление, но с помощью модульной арифметики и представления `27` степенями двойки это получается быстро и эффективно.

Для начала представляем `27` как сумму степеней двоек.
`27 = 16 + 8 + 2 + 1 = 2^4 + 2^3 + 2^1 + 2^0`

Теперь считаем `14` в каждой степени двойки до максимальной используемой в `27`. При этом на каждом следующем этапе мы подставляем в выражение уже вычисленный ранее результат.
- `14^1 %  55 = 14`
- `14^2 = 14^1 * 14^1 = 14 * 14 = 196 %  55 = 31`
- `14^4 = (14^2)^2 = 31^2 = 961 %  55 = 26`
- `14^8 = (14^4)^2 = 26^2 = 676 %  55 = 16`
- `14^16 = (14^8)^2 = 16^2 = 256 %  55 = 36`

Остается только перемножить остатки всех используемых степеней и посчитать остаток от них: `14^27 ≡ 14^16 * 14^8 * 14^2 * 14^1 % 55 = 36 ⋅ 16 ⋅ 31 ⋅ 14 % 55 = 9`
### Почему это работает?

В модульной арифметике важен только остаток, а не само число. То есть, если два числа [конгруэнтны](Конгруэнтность) по модулю `m`, то все их степени, произведения и суммы тоже будут конгруэнтны по модулю `m` - это одно из свойств модульной арифметики.

Это значит буквально следующее: если `a ≡ b mod m`, то:
- `a + c ≡ b + c mod m`
- `a · c ≡ b · c mod m`
- `a^c ≡ b^c mod m`

Также `(n mod m) mod m = n mod m` просто по определению: сколько угодно ты дели посчитанный остаток на модуль - ты получишь тот же самый остаток.
А значит, и `n^k mod m = (n mod m)^k mod m`. Это свойство следует из *согласованности операций в [[Кольцо|кольце вычетов]] по модулю* `m`: ты можешь взять остаток на любом этапе - до вычисления или после - результат не изменится.

Интуитивно, можно считать, что [мы сокращаем всё множество возможных чисел до множества лишь тех, которые возможно получить взятием модуля](Кольцо) `m`, но правила вычислений при этом не меняются, операции сложения и умножения остаются определены и все так же работоспособны.

#модульнаяарифметика
