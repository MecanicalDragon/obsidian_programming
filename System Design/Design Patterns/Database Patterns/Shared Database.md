Usually, shared database is an anti-pattern for microservices. But if the application is a monolith and trying to break into microservices, denormalization is not that easy. Later phase we can move to DB per services pattern; till that we make follow this. A shared database per service is not ideal, but that is the working solution for the above scenario. Most people consider this an anti-pattern for microservices, but for brownfield applications, this is a good start to break the application into smaller logical pieces. This should not be applied for greenfield applications. Here are some premises to pick a shared database pattern:

- **Data consistency and integrity**: If your microservices heavily rely on interrelated data or have strong consistency requirements, a shared database can help maintain data integrity and enforce complex relationships. With a shared database, you can perform atomic transactions that involve multiple microservices, ensuring consistent and coordinated updates across the system.
- **Data sharing and collaboration**: Some microservices may require access to common data or need to collaborate by sharing information. A shared database allows these microservices to directly access and share data, avoiding the need for complex data synchronization mechanisms or redundant data storage.
- **Simplified querying and reporting**: In situations where reporting or complex queries span multiple microservices, a shared database can simplify data retrieval and analysis. Instead of making numerous API calls and aggregating data across services, a shared database provides a central location for querying and generating reports efficiently.
- **Legacy system integration**: If you are migrating from a monolithic system with an existing shared database, it may be challenging to decompose the database into separate ones for each microservice. In such cases, using a shared database temporarily or as a transitional phase can help facilitate the migration process while gradually decoupling the services.
- **Simplified deployment and infrastructure**: A shared database reduces the complexity of managing and deploying multiple databases. It requires fewer resources and reduces the operational overhead associated with managing and monitoring multiple database instances.

Shared database can address specific requirements, but it also comes with trade-offs. It introduces tighter coupling between microservices, making it harder to evolve and scale them independently. A shared database can also become a bottleneck if multiple microservices frequently read or write to it concurrently, impacting performance and scalability. Additionally, it may complicate data governance and access control since multiple services have direct access to the same data. Therefore, before opting for a shared database, carefully evaluate your system requirements, the nature of your data, and the potential impact on microservice autonomy, scalability, and fault isolation. Consider alternative patterns like event-driven architecture, messaging systems, or distributed caching to address specific data sharing or collaboration needs while maintaining the benefits of microservices.
