**Над чем подумать в самом начале:
1. Насколько уникальным должен быть ID?
	- В рамках одного сервиса
	- Уникальным в пределах системы в течение какого-то времени
	- Глобально уникальным в течение всей жизни системы
	Два последних варианта влияют на длину id. Чем он короче, тем скорее наступит переполнение. Чем длиннее — тем больше памяти займёт id 

2. Как часто нужно генерировать id? Насколько защищенным и непредсказуемым он должен быть?

3. Если сущность отдаётся за пределы системы, что видит внешний пользователь?
	- id как есть: `/user/123`
	- Декодированный id через Base64: `/user/MTIz`
	- Зашифрованный id: `/user/67FA78`
4. Формат
	- Возрастающая последовательность: глобальный счётчик, последовательность в БД или местный AtomicLong
	- Случайный набор цифр: глобально уникальный UUID или локальный Random - самый быстрый вариант
	- Вариации *Snowflake*: формат Snowflake придумали в Twitter. В оригинале id формируется как комбинация `timestamp + machine_id + sequence_id` (значения складываются как строки, а не как числа), где `timestamp` — количество миллисекунд, `machine_id` — id сервера, `sequence_id` — возрастающая последовательность. Плюсы такого подхода:
		- id содержит что-то полезное
		- Можно сортировать по полям, входящим в id
		- Глобальная уникальность

**Технические моменты Snowflake**

Чтобы timestamp не получался слишком большим, можно отсчитывать миллисекунды от какой-то даты отсчёта. 

Machine id часто меняют на пару `id рабочей машины + id процесса` или `id датацентра + id сервера`. Можно вдохновиться и составить свою комбинацию полей.
Machine id извлекается в начале работы сервиса
- из распределённого счётчика. Например, из Zookeeper
- из конфига, если при развёртывании ведётся счётчик

Для возрастающей последовательности подойдёт локальный AtomicLong или sequence в БД.

**Генерация ID в базе данных**

Часто говорят, что генерация id через БД — плохое решение. Все сущности должны проходить через один экземпляр БД, чтобы не было дубликатов, и это ограничивает масштабируемость. Генерация через БД подходит, если объект и так сохраняется в базе данных. Если взаимодействий с БД нет (например, нужно id сообщения для кафки), конечно, нужны другие решения.
