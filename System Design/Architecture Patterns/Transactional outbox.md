Sometimes the service needs to update the database and send a message or emit an event, and do it atomically ([[SAGA]] participant). Or an application that follows DDD needs to atomically publish a *domain event* and update an *aggregate*. In this scenario service that uses a relational database inserts messages/events into an *outbox table* as part of the local transaction. A service that uses a NoSQL database appends the messages/events to the attribute of the record or document being updated. Simultaneously a parallel scheduled process publishes events inserted into the database to a message broker.

A Scheduled Message Publisher might publish a message more than once (if it crashes, for example). As a result, a message consumer must be idempotent, perhaps by tracking the IDs of the messages that it has already processed. Ordering messages in the outbox table also allows to keep messages order the same as transactions order, that usually is required.

[transactional outbox](https://microservices.io/patterns/data/transactional-outbox.html)
