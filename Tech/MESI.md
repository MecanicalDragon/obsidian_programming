**MESI** (Modified, Exclusive, Shared, Invalid) - **протокол когерентности**, который используют процессоры, чтобы обеспечить консистентность данных между кэшами разных ядер:

1. **Modified (M)** - Кэш-линия была изменена этим ядром, и в оперативной памяти её данные устарели. У других ядер эта кэш-линия помечается как *Invalid*, и при её передаче другому ядру данные нужно записать в память или отдать напрямую.
2. **Exclusive (E)** - Кэш-линия только у этого ядра, и её данные не были изменены, совпадают с RAM. Если ядро решит изменить данные, кэш-линия может сразу перейти в состояние *Modified*.
3. **Shared (S)**- Кэш-линия у нескольких ядер одновременно, но данные не были изменены и совпадают с оперативной памятью. Все ядра могут читать, но ни одно не может писать, пока не перейдёт в другое состояние.
4. **Invalid (I)** - Кэш-линия устарела, её нужно перезагрузить при следующем доступе. Это состояние присваивается, если другое ядро изменило данные.

**Как это работает**
- Все кэши ядер согласовывают владение [[Cacheline|кэш-линиями]] через общую аппаратную шину. Это называется *Cache snooping* — прослушивание кэшей, или, на уровне CPU, *snoop-based cache coherence protocol*.
- Если ядро хочет модифицировать кэш-линию, оно посылает на шину "Запрос на модификацию" (*RFO — Read For Ownership*). Другие ядра видят этот запрос.
- Если у какого-то другого ядра эта кэш-линия находится в `Shared` или `Exclusive`, оно инвалидирует свою копию - помечает как `Invalid`.
- Если же другое ядро держало кэш-линию в состоянии `Modified`, оно отдает ее запросившему ядру и всё равно инвалидирует.
- Теперь первое ядро теперь имеет кэш-линию в состоянии `Modified` и может её менять.

Да, MESI подвержен [[Concurrency problems#^livelock|Live Lock]], но он и не гарантирует "завершения работы", только когерентность. Он не знает, когда операция "логически завершена", а просто реагирует на запросы других ядер и обязан "уступить". Производители CPU решают эту проблему введением арбитража и приоритета владения, ограничением *RFO* и временной блокировкой повторных запросов - [[Concurrency problems|всё по теории]].

Также на практике вместо традиционного MESI используется *MESIF* (в Intel) и *MOESI* (в AMD) - они добавляют состояния типа F (Forward) и O (Owned), чтобы оптимизировать передачи между кэшами без обращения в RAM. Эти улучшения делают многопоточную работу быстрее.
#### See Other:
- [[False Sharing]]
- [[Cacheline]]
- [[Prefetch]]
