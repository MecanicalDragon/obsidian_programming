**Java NIO** (aka New IO aka Non-blocking IO) – часть стандартной библиотеки Java, предназначенная для работы с вводом-выводом. В NIO значительно отличаются подходы по чтению и записи данных. Java NIO: Неблокирующий, Асинхронный, Буфер-ориентированный. Лучше разбирать всё это с конца:

**Буфер-ориентированный**

Если в IO работа с данными потокоориентированная и происходит побайтово/посимвольно (или с массивами байт/символов), таким образом, невозможно перемещаться по потоку вперёд-назад, то NIO работает с буферами, которые можно воспринимать как высокоуровневые обёртки над массивом байт. В отличии от буферизации в том же BufferedInputStream (и прочих Buffered*), программисту даётся полный контроль над буфером: существует большое число методов по модификации его содержимого, навигации и т.д. Это накладывает определённый уровень ответственности на программиста – он сам должен следить за тем, считалось ли достаточно данных для дальнейшей обработки.

**Асинхронный**

В IO read/write инициирует процесс получения данных: например, чтение из файла на жёстком диске. В NIO же данные в канал поступают независимо от программы – достаточно связать канал с источником данных, и при их появлении они будут «кэшироваться» в нём. Операция чтения из канала просто получит уже имеющиеся в нём данные.

**Неблокирующий**

При работе с обычными потоками ввода-вывода вы обычно вызываете метод read (write) для получения очередной порции данных. Поток в этот момент блокируется – останавливается до тех пор, пока эти данные не появятся в потоке. Традиционно операции ввода-вывода считаются долгими, потому программа начинает неэффективно использовать процессорное время. NIO же не ожидает появления данных в канале, а получает уже имеющиеся в нём данные, а если их нет – не получает ничего, после этого поток может перейти к исполнению следующих инструкций. Это может дать определённые преимущества: селекторы в Java NIO позволяют одному потоку выполнения обслуживать несколько каналов ввода\вывода.

Java NIO отнюдь не является заменой Java IO. Его стоит рассматривать как усовершенствование – инструмент, позволяющий значительно расширить возможности по организации ввода/вывода.
## EventLoops

**EventLoop** is a NIO Thread which runs continuously and takes new requests from a range of [SocketChannels](https://docs.oracle.com/javase/7/docs/api/java/nio/channels/SocketChannel.html) (for every incoming request java creates its own [socket](https://docs.oracle.com/javase/tutorial/networking/sockets/definition.html) to read it and write response. SocketChannel is a NIO set of sockets). If there are multiple EventLoops, then each EventLoop is assigned to a group of SocketChannels and all EventLoops are managed under a EventLoopGroup. If the application uses Netty and Reactive WebClient, then EventLoop resources will be shared.

[Source](https://singhkaushal.medium.com/spring-webflux-eventloop-vs-thread-per-request-model-a42d07ee8502)
