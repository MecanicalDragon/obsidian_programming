**MethodHandle** is a low-level mechanism for finding, adapting and invoking methods. Method handles were introduced in order to work alongside the existing java.lang.reflect API, as they serve different purposes and have different characteristics. Furthermore, MH takes some responsibilities of the [[Unsafe]] too â€“ creation of the [[Hidden Classes]], for instance.

MethodHandles are faster than the Reflection API since the access checks are made at creation time rather than at execution time. This difference gets amplified if a security manager is present, since member and class lookups are subject to additional checks. MethodHandles API offers the possibility to [curry](https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%80%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) methods, change the types of parameters and change their order.

Reflection is a general-purpose introspection mechanism, which includes many features that the MH mechanism lacks, such as enumerating the members of a class (`Class.getMethods()`), inspecting the characteristics of a member such as its accessibility flags, inspecting generic signatures of members, etc. Additionally, reflective objects can be freely shared without granting access to the sharee, because the access checks are made at each invocation. Sharing MH, in its turn, confers to the sharee the capability to invoke.

Method handles are a low-level mechanism for finding, adapting, and invoking methods. While invocation through method handles is faster than through reflection (though to date, direct bytecode invocation is still generally faster than method handle invocation), method handles are also significantly harder to use, as they do not automatically perform the adaptations Java users would expect (such as converting a String argument to Object), resulting in linkage errors.

The reflection library is aimed at mainstream Java users; the method handle layer aims more at compiler and language runtime writers.
