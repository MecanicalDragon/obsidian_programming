Виртуальные потоки (**Project Loom**) добавлены как стабильная фича в *JDK 21*. Для их работы используется библиотека `java.lang.Continuation`. Виртуальные потоки выполняются поверх обычного [[Executors#^fjp|ForkJoinPool]] (отдельного, не *common pool*, с параллелизмом по умолчанию по количеству ядер) пула реальных потоков, называемых в данном контексте **carrier threads**. Когда виртуальный поток блокируется на I/O, он **паркуется** - его состояние сохраняется в *continuation*, а carrier берется за исполнение другого виртуального потока. 
`Thread vt = Thread.ofVirtual().start(() -> doWork());`

**Continuation** — это объект, который умеет:
- приостанавливать выполнение метода (парковать стек),
- сохранять состояние стека (включая локальные переменные, счётчик команд),
- возобновлять выполнение с того места, где остановился.

В отличие от обычного `Thread`, чей стек живёт в [[Java Native Memory Tracking|отдельной области памяти]], *continuation* хранит стек в хипе (*heap-allocated stack*), поэтому его можно безопасно снять с одного carrier-потока и продолжить на другом.

Каждый виртуальный поток имеет собственный *stack chunk* (кусок стека), который JVM может динамически расширять. Он не фиксирован 1–2 МБ, как у обычного потока. При паркинге эти куски сворачиваются и складываются в кучу как linked list. Continuation содержит ссылки на эти чанки и счётчик позиции, где виртуальный поток остановился. При возобновлении эти чанки разворачиваются обратно на carrier, и выполнение продолжается.

**Loom** «учит» стандартные IO API парковать continuation вместо блокировки carrier. На блокирующем месте JVM перехватывает вызов (через интеграцию с `LockSupport`, `java.nio`, `java.net`, `java.util.concurrent`, таймеры `sleep` и `parkNanos` и тд.), и стек виртуального потока сохраняется в heap, а carrier освобождается.

Если библиотека блокирует поток мимо этих точек (где-нибудь в нативном коде через `JNI`, о которой JVM ничего не знает), это приводит к *pinning* carrier потока - он блокируется. Также, если блокирующая операция исполняется внутри `synchronized`, JVM не может отпарковать continuation, потому что монитор привязан к конкретному carrier — поток также *пиннится*. В таких случаях чтобы не терять параллелизм планировщик может временно добавить ещё один carrier (в разумных пределах), компенсируя «забитый» поток.

Когда условие готово (epoll/kqueue/IOCP, таймер, разморозка lock), continuation попадает в *очередь*. Любой свободный carrier размонтирует continuation и продолжит с той же инструкции, на которой виртуальный поток был остановлен.

Планировщик использует **рабочие очереди** carrier-потоков и **глобальную очередь**. Когда виртуальную нить нужно запустить/возобновить, JVM помещает её continuation в одну из этих очередей. Обычно Carrier берёт задачу из своей локальной очереди; при нехватке — ворует из другой или из глобальной (тот самый *work-stealing*). Нет тайм-квантов и вытеснения: виртуальный поток «уступает» планировщику только когда блокируется или явно вызывает `Thread.yield()`. "Планировщик" - это не какой-то класс, это новый отдельный механизм в JVM с [[Executors#^fjp|WorkStealingPool]] под капотом.

---
Loom блестяще масштабирует *I/O-bound*, но не заменяет обычный параллелизм для *CPU-bound* задач. Если запустить долгий CPU-bound код без блокировок, виртуальный поток будет исполняться на том же самом carrier до самого конца - это не хуже обычных потоков, но и выигрыша тоже не будет. Для I/O-bound же каждая блокировка превращается в «уступку» планировщику, поэтому сотни тысяч соединений обрабатываются малыми силами. Однако:
- ограничения внешних сервисов и лимиты БД никуда не деваются - *Semaphore*, *RateLimiter* для внешних ресурсов обязательны. Нужно следить за *backpressure*.
- про `synchronized` вообще стоит забыть; при необходимости юзать `ReentrantLock`.
- память тоже не бесконечна; каждый виртуальный поток всё равно имеет стек и метаданные (намного меньше, чем у обычного потока, но не ноль), а самих виртуальных потоков намного больше.
- планировщик масштабируется хорошо, но ускорение не бесконечное: упираешься в CPU/latency внешних систем.
- нужно следить за «*pinned virtual thread*» в логах/профилировщике.
