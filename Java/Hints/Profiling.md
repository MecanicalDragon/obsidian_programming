Java profilers inspect the state of the JVM either by passively listening for events from the JVM or by actively querying the JVM for its state. JVM has profiling functions that return data about its internal state: *GetThreadState* and *GetAllThreads*, *GetStackTrace* and *GetAllStackTraces*. These internal state data are queried periodically by the profiler in a process known as *sampling*. Sample events (also called requestable events) are logged at a regular interval to provide a sample of system activity. You can configure how often sampling occurs.

Also, profilers can modify the bytecode of classes to add instrumentation code, like inserting different event emission (*methodEntered*, *methodExit*, or *objectCreated* event). Profilers can listen to JVM events too. There are lots of events that are generated by the JVM, and these can be categorized into two types:
- **Instant events** are one-time events that have a timestamp and the event data (exception events, class load events, object allocation events).
- **Duration events** have a start time and an end time and are therefore used to provide timing for some activity (garbage collection, monitor wait).    

Profilers monitor JVM execution at the bytecode level and can provide various information. These include CPU, memory, thread, I/O profiling, and others. I/O profiling is not widely spread but can be critical in some kinds of applications.
- **Thread profiling** monitors thread states and helps to detect locks and starvation, so it can be useful when application performance is low, but CPU consumption is low either.
- **Memory profiling** reviews garbage collection, objects lifecycle and memory consumption.
- **CPU profiling** is primarily concerned with the frequency and length of time of method execution.

There are two ways in which profilers can get method execution information:
- **Sampling**. Profiler periodically queries JVM for all the running threads and their stack traces. It then determines what method each thread was executing when the sample was taken and compares the samples to determine how much time was spent in that method. Profiling by sampling has the least amount of overhead, but it is low-accurate and, hence, error-prone. Reducing the interval between samples increases both the overhead on the JVM and accuracy.
- **Instrumenting**. Profiler modifies application's bytecode and inserts code for counting invocations or timing methods. This makes the profiler more accurate but hits performance more significant either. Furthermore, depending on how the instrumentation is done there may be some optimizations that could have been applied to the non-instrumented code that can't be applied to the instrumented code.

[source 1](https://stackify.com/what-are-java-agents-and-how-to-profile-with-them/), [source 2](https://dzone.com/articles/how-java-profilers-work), [source 3](https://www.baeldung.com/java-instrumentation), [source 4](https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH170)
