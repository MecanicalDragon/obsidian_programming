The UUID standard defines five variations, with different properties and potential disadvantages. Depending on UUID version and the specific implementation:<br>
- IDs take up a lot of space, especially when serialized as strings
- malefactor is able to trace a UUID to the computer that generated it
- a system can not reliably generate more than one unique UUID every 7 seconds
- pseudo-random generation may fail to prevent duplicate IDs
- the implementation might generate IDs that donâ€™t comply with the standard.
<br>Java UUID versions:<br>
1. Version 1 concatenates the 48-bit MAC address of the node with a 60-bit timestamp
2. RFC 4122 reserves version 2 for "DCE security" UUIDs; but it does not provide any details. For this reason, many UUID implementations omit version 2. However, Version-2 UUIDs are similar to version 1, except for some small changes.
3. Versions 3 and 5 are generated by hashing a namespace identifier and name. Version 3 uses MD5 as the hashing algorithm, and version 5 uses SHA-1. These UUIDs have the property that the same namespace and name pair will create the same UUID. However, neither the namespace nor name can be determined from the UUID, even if one of them is specified, except by brute-force search. RFC 4122 recommends version 5 (SHA-1) over version 3 (MD5) and warns against use of UUIDs of these versions as security credentials.
4. A version 4 UUID is randomly generated. Under the hood it uses SecureRandom and may slow down highly loaded applications.

[wiki](https://en.wikipedia.org/wiki/Universally_unique_identifier)
[UUID versions features](https://www.sohamkamani.com/uuid-versions-explained/)
[Correlation Id for microservice architecture](https://hilton.org.uk/blog/microservices-correlation-id)
[Base62-CID](https://www.bandwidth.com/blog/a-recipe-for-adding-correlation-ids-in-java-microservices/)
[CID Recipe](https://www.bandwidth.com/blog/a-recipe-for-adding-correlation-ids-in-java-microservices)
