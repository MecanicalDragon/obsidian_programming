[This is the Oracle explanation](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html). 

Briefly, Java keeps integer and decimal parts of the `double` in the same way; this allows JVM to avoid extra transformations during calculation and do calculations fast. Integer parts are stored in java as a sum of powers of 2: `9 = 8 + 1 = 2^3 + 2^0 -> 1001`. Decimal parts of doubles are stored as a negative power of 2, and sometimes it goes well: `0.5 = 2^(-1) -> 0.1` But sometimes is doesn't: `0.1 = 2^(-4) + 2^(-5) + 2^(-8) + … -> 0.00111101110011001100110011001` For precise calculations there exist 3 ways: limited-precision decimal, symbolic calculations, and arbitrary-precision decimal; the last one is used in BigDecimal. 

BigDecimal keeps numbers as a pair of an integer and a number of digits in the decimal part of this number. It has a lot of flaws but gives precision. 0.2 as a `double` and 0.2 as a `String`, being passed into the constructor of BigDecimal, are not equal, because in reality double 0.2 is `0.20000000000000001110223…`
