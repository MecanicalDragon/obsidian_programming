
| for                                                                                                                                                                                                                                                  | forEach                                                                                                                                                                                                                                                                                            |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Обходит структуру по принципу итерации (в Java нет сложных структур, и следующий элемент всегда однозначен).                                                                                                                                         | Использует для обхода траверс (так называется обход структуры данных в computer science, где сложные структуры вроде графа – обычное дело).                                                                                                                                                        |
| указатель на следующий элемент вычисляется заранее, таким образом, если мы удалили или поменяли элемент, который должен вывестись следующим, то итератор не подхватит изменений и выведет старое значение.                                           | Следующий элемент вычисляется только когда понадобится, поэтому, если мы при обходе добавим новый элемент, он будет обнаружен.                                                                                                                                                                     |
| Используемый подход называется external iteration или внешний обход. Последовательно идём по элементам коллекции и применяем к ним некоторую логику. С коллекцией общаемся через интерфейс. Главный путь оптимизации - оптимизация логики обработки. | Мы как бы передаём функцию внутрь структуры данных, и она сама решает, как её применить исходя из деталей своей реализации. Логика обработки скрыта за функциональным интерфейсом, а структура данных ей пользуется. Это называется internal iteration или внутренний обход.                       |
| Логика обработки - ведущий игрок, все оптимизации здесь. Структура данных - абстракция, скрыта за интерфейсом.                                                                                                                                       | Логика обработки доступна через интерфейс. Структура данных - главная, оптимизации происходят на этом уровне.                                                                                                                                                                                      |
|                                                                                                                                                                                                                                                      | Работу над коллекцией легко делить между потоками. Раньше это было невозможно - логика обработки могла быть любой и параллелить в каждом случае нужно по-разному. Деление на подзадачи на уровне структуры данных гораздо проще, и теперь у нас есть библиотечный метод `parallel()` в Stream API. |
*Почему нельзя использовать траверс по умолчанию?*
>Итератор проще и работает быстрее, а условия для пропуска элемента при обходе встречаются редко.

*Зачем нужно несколько вариантов?*
>*ConcurrentHashMap* может перестраиваться во время обхода. Чтобы во время перестройки не выводить дубликаты, используется траверс со сложной логикой.

Для однопоточных коллекций между `for` и `forEach` нет никакой разницы, в обоих случаях используется итератор.
