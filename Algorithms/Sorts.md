
| Sort                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Time(BAW)                                    | Mem                                    | Stbl   | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------- | -------------------------------------- | ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Bubble Sort                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | `O(n)`<br>`O(n²)`<br>`O(n²)`                 | ***O(1)***                             | Yes    | Алгоритм состоит в повторяющихся проходах по сортируемому массиву. На каждой итерации последовательно сравниваются соседние элементы, и, если порядок в паре неверный, то элементы меняются местами.                                                                                                                                                                                                                                                                           |
| [Insertion Sort](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%B2%D1%81%D1%82%D0%B0%D0%B2%D0%BA%D0%B0%D0%BC%D0%B8)                                                                                                                                                                                                                                                                                                                                                                                                                 | `O(n)`<br>`O(n²)`<br>`O(n²)`                 | ***O(1)***                             | Yes    | На каждом шаге алгоритма мы выбираем один из элементов входных данных и вставляем его на нужную позицию в уже отсортированной части массива до тех пор, пока весь набор входных данных не будет отсортирован.                                                                                                                                                                                                                                                                  |
| [Shell Sort](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%A8%D0%B5%D0%BB%D0%BB%D0%B0)                                                                                                                                                                                                                                                                                                                                                                                                                                             | `O(n·log²n)`<br>Depends<br>`O(n²)`           | ***O(1)***                             | ==No== | Модификация сортировки вставками, которая сначала сортирует между собой элементы, стоящие на расстоянии `d` друг от друга. `d` постепенно уменьшается, и при `d = 1` происходит сортировка вставками. Хоть сортировка и медленнее быстрой, но не требует доп. памяти под стек и не так сильно деградирует на неудачных данных, как быстрая.                                                                                                                                    |
| [Quick Sort](https://ru.wikipedia.org/wiki/%D0%91%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0)<br>$\tiny and$<br>[Dual-pivot quicksort](https://stackoverflow.com/questions/20917617/whats-the-difference-of-dual-pivot-quick-sort-and-quick-sort)                                                                                                                                                                                                                                                                             | `O(n·log n)`<br>`O(n·log n)`<br>`O(n²)`      | `log n`<br>$\tiny degrades\ to$ `O(n)` | ==No== | Алгоритм состоит в выборе опорного элемента и разделении массива на 2 части относительно него: элементы, меньшие опорного и большие, и в сортировке полученных частей рекурсивным вызовом себя от них. [Dual-pivot quicksort](https://stackoverflow.com/questions/20917617/whats-the-difference-of-dual-pivot-quick-sort-and-quick-sort) разбивает массив на 3 части, что дает существенный прирост производительности в случаях, когда в массиве много повторяющихся величин. |
| [Heap Sort](https://ru.wikipedia.org/wiki/%D0%9F%D0%B8%D1%80%D0%B0%D0%BC%D0%B8%D0%B4%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0)                                                                                                                                                                                                                                                                                                                                                                                              | `O(n·log n)`<br>`O(n·log n)`<br>`O(n·log n)` | ***O(1)***                             | ==No== | Проходим по массиву и строим из него [[Trees#^heap\|кучу]] `(a[i] >= a[2i+1] && a[i] >= a[2i+2])`. Затем поочереди перемещаем корень кучи в конец массива и перестраиваем саму кучу без учета уже отсортированного последнего элемента.                                                                                                                                                                                                                                        |
| Tree Sort                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | `O(n)`<br>`O(n·log n)`<br>`O(n·log n)`       | `O(n)`                                 | Yes    | Поочереди добавляем вершины в [[Trees#^bst\|сбалансированное дерево поиска]], затем проходим по всем вершинам в порядке возрастания.                                                                                                                                                                                                                                                                                                                                           |
| [Merge Sort](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC)<br>$\tiny and$<br>[Enhanced Merge Sort](https://neerc.ifmo.ru/wiki/index.php?title=C%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC_%D1%81_%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%D0%BC_O\(1\)_%D0%B4%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8) | `O(n·log n)`<br>`O(n·log n)`<br>`O(n·log n)` | `O(n)`<br>$\tiny and$<br>***O(1)***    | Yes    | Алгоритм состоит в разделении массива пополам, сортировке половин и их слиянии, и так рекурсивно. `O(1)` по памяти в *EMS* достигается тем, что в качестве буфера используется часть самого массива.                                                                                                                                                                                                                                                                           |
| [TimSort](https://ru.wikipedia.org/wiki/Timsort)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | `O(n)`<br>`O(n·log n)`<br>`O(n·log n)`       | `O(n)`                                 | Yes    | Гибрид сортировки слиянием. Разбиваем массив на подмассивы (*minrun* – минимальная длина подмассива, *run* – упорядоченный подмассив во входном массиве) и сортируем каждый подмассив любой устойчивой сортировкой. После чего объединяем отсортированные подмассивы модифицированной сортировкой слиянием.                                                                                                                                                                    |
| Bucket Sort<br>$\tiny or$<br>Radix Sort<br>$\tiny or$<br>Digital Sort                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | `O(n+k)`<br>`O(n·logₖn)`<br>`O(n·k)`         | `O(n)`                                 | Yes    | Сортировка работает для чисел и других элементов, которые можно разбить на упорядоченные группы. Распределяем элементы в `k` карманов так, чтоб все элементы каждого следующего кармана были больше всех элементов предыдущего (для чисел это [radix](https://en.wikipedia.org/wiki/Radix)), сортируем элементы внутри карманов, затем просто собираем карманы по порядку в результирующий массив.                                                                             |
| Counting Sort                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | `O(n+k)`<br>`O(n+k)`<br>`O(n+k)`             | `O(k)`                                 | Yes    | Сортировка целых чисел, входящих в какой-то небольшой диапазон. Создаем массив длины диапазона, каждый элемент которого будет показывать, сколько исходных элементов равны данному. Бежим по массиву и считаем количество вхождений каждого числа.                                                                                                                                                                                                                             |
[Sorts](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8) and [Sorts](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8)
### Sorting in Java

Currently, situation in Java (including Java 8 to Java 11) is as follows:
- For **objects**, since they *have identity* and need *stable sort*, Java uses [TimSort](https://en.wikipedia.org/wiki/Timsort).
- For **large arrays of primitives** java tries to identify *runs* of pre-sorted data first, like [TimSort](https://en.wikipedia.org/wiki/Timsort) does, and then merges them if the number of runs does not exceed a certain threshold. Otherwise, since primitives *don’t have identity*, Java uses [Quicksort](https://en.wikipedia.org/wiki/Quicksort), but with an implementation that falls back to the [Insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) for small ranges.
- For **chars** and **shorts** added another special case - using [Counting sort](https://en.wikipedia.org/wiki/Counting_sort) for arrays whose length exceeds a certain threshold, [Quicksort](https://en.wikipedia.org/wiki/Quicksort) otherwise.
- For **bytes** will be used [Insertion sort](https://en.wikipedia.org/wiki/Insertion_sort) for small arrays and [Counting sort](https://en.wikipedia.org/wiki/Counting_sort) otherwise.
