В основе RSA шифрования лежит *малая теорема Ферма*:
Если `p` - простое число и `a` - целое число, *взаимно простое* с ним (т.е. их единственный общий делитель - `1`, на математическом языке `gcd(a,p) = 1` (*greatest common divisor*)), то `a^(p−1) − 1` делится на `p`. *(^0)*
Теорему обобщил Эйлер, выведя свою теорему, которую, в свою очередь, обобщил Гаусс.
### Функция Эйлера

Функция Эйлера `φ(n)` - функция, значение которой от `n` равно количеству натуральных чисел меньше `n` и *взаимно простых* с ним. Чтобы ее вычислить для числа `n`, нужно перебрать все числа от `1` до `n` и каждое проверить на общие делители, что очень ресурсоемкий процесс.

Одним из основных свойств функции Эйлера является её *мультипликативность*: для любых *взаимно простых* `m` и `n` (`gcd(m,n) = 1`) -> `φ(mn) = φ(m)φ(n)`. *(^1)*

Для простого числа `p` значение функции Эйлера задаётся явной формулой: `φ(p) = p−1`, которая следует из определения. Действительно, если `p` - простое число, то все числа меньше него взаимно просты с ним, и их ровно `p-1` штук. *(^2)*

Для вычисления функции Эйлера от степени простого числа используют следующую формулу: `φ(p^n) = p^n − p^(n−1)`. Это равенство обосновывается следующим образом.
Подсчитаем количество чисел от 1 до `p^n`, которые НЕ взаимно просты с ним. Все они, очевидно, кратны `p`, ибо оно простое: `2p`, `3p`, `4p`...`p^(n-1)p`. Всего таких чисел будет `p^(n-1)`, а значит, количество взаимно простых с `p^n` чисел равно `p^n − p^(n−1)`.
### Теорема Эйлера

Если число `n` *взаимно простое* с числом `m` (`gcd(m,n) = 1`)***(0)***, то `n^(φ(m)) ≡ 1 mod m`, то есть, `n` в степени равной значению функции Эйлера от `m` будет числом, которое при делении на само `m` даст остаток единицу *(^3)*.

Если при этом `m` - простое число, то из ***(2)*** следует, что `n^(m-1) ≡ 1 mod m`, что как раз и является *малой теоремой Ферма*.
### Шифрование

`p`, `q` - два больших простых числа, хранятся в тайне (возьмем `5` и `11`).

`m = p * q` — *модуль*, хранится и в публичном, и в приватном ключе (`5 * 11 = 55`). 

`f = φ(m)` - функция Эйлера от модуля, хранится в тайне. `φ(m) = φ(pq) = φ(p) * φ(q)` ***(1)***, а так как `p` и `q` - простые числа, то `f = (p−1) * (q−1)` ***(2)***. 
`m = 5 * 11 = 55` => `f = 4 * 10 = 40`.

Числа `p` и `q` обязательно  должны быть *простыми* - только тогда они позволяют эффективно высчитать значение `f` и гарантировать, что операция шифрования будет обратима операцией дешифрования.

`e` - публичная экспонента (показатель степени), открытая часть ключа. Это число должно быть *взаимно простым* с `f` - тогда теорема Эйлера гарантирует *мультипликативную обратимость* `e` по модулю `f`, то есть `d`, которое удовлетворяет условиям ***(3)*** гарантированно существует. `e` не обязательно должно быть простым числом, но на практике это часто `65537`, что равно `2^16 + 1` и удобно для вычислений.
Возьмем для примера `3`, *взаимно простое* с `40`.

`d` - приватная экспонента, секретная часть ключа - такое число, что `e * d ≡ 1 mod f`, то есть, `d` - *обратное по модулю* к `e` число `f`, что означает, что `e * d` даст остаток `1` при делении на `f`, то есть, `d ≡ e^-1 mod f`, или `d ≡ 1/e mod f`.
Найти `d` можно с помощью *расширенного алгоритма Евклида* (работающего за `O(log⁡ n)`, к слову), но для примера можно и просто добавить `1` и прибавлять `f` пока число не будет делиться на `e`.
Найдем такое `d`, чтоб будучи помноженным на `3`, оно давало результат, который поделится на `40` с остатком `1`: `3d ≡ 1 (mod 40)` => `40 + 1 + 40 = 81 % 3 = 0` => `81 / 3 = 27`

В итоге имеем ключи:
- **Публичный ключ**: `(e,m)` = (3,55)
- **Приватный ключ**: `(d,m)` = (27,55)
### Практика

**Зашифруем сообщение:** `9`:
- `enc = 9^e mod m = 9^3 mod 55 = 729 mod 55 = 14`

**Расшифруем:**
- `dec = 14^d mod m = 14^27 mod 55 = 9`

`14^27` - сложное вычисление, но с помощью [[Модульная Арифметика|модульной арифметики]] и представления 27 степенями двойки это получается быстро и эффективно.
### Почему это работает?

Если вкратце, то из-за теоремы Эйлера ***(3)***: сообщение `n` и модуль `m` *взаимно просты*. Это гарантировано почти наверняка из-за того, что `m` достаточно велико, а сообщение `n` перед шифрованием еще и модифицируется алгоритмами *паддинга*, чтобы возвести эту вероятность в практический абсолют. 
	Проверить *взаимную простоту* 2 чисел можно найдя `gcd` с помощью *обычного алгоритма Евклида* (работающего также за `O(log⁡ n)`, к слову), но на практике используют алгоритмы паддинга вроде *PKCS#1 v1.5* или *OAEP*, сводящие вероятность получения плохого числа для шифрования к просто ничтожным значениям - для `p` и `q` длиной в 1024 бита примерно `2^(-1023)`. К тому же, паддинг позволяет избежать *фиксаций* (*fixed point*) - это когда число для шифрования получается таким, что зашифрованное, оно остается собой же, то есть, сообщение не меняется при шифровании. 
Таким образом, теорема Эйлера начинает работать. Мы возводим сообщение в степень `e` при шифровании, а затем и в степень `d` при расшифровке, и на каждом этапе сокращаем результат до модуля.

Одно из свойств модульной арифметики - *согласованность операций в [[Кольцо|кольце вычетов]]*, то есть, `(n mod m)^d mod m = n^d mod m`. Таким образом, если `n` - исходное сообщение, `enc = n^e mod m` => `dec = enc^d mod m = (n^e mod m)^d mod m = n^ed mod m`, но `ed ≡ 1 mod φ(m)` - мы так их сами выбрали.

Конгруэнтное выражение можно привести к обычному равенству следующим способом: `ed ≡ 1 mod φ(m)` => `ed = 1 + kφ(m)`, где `k` - это некий множитель, необходимый чтобы уравнять неравенство (в примере в главе про шифрование это `2`, например).

Подставляем полученное выражение в имеющееся преобразование исходного сообщения:
`n^ed = n^(1 + kφ(m)) = n * n^kφ(m)` => `n^ed mod m = n * n^kφ(m) mod m`
`n^(φ(m)) ≡ 1 mod m` - теорема Эйлера ***(3)***
`1^k = 1` => `(n^φ(m))^k ≡ 1^k mod m ≡ 1 mod m`
`n * 1 = n` => `n * (n^φ(m)) ≡ 1n mod m`
=> `n * n^kφ(m) mod m ≡ n mod m` => `n^ed ≡ n mod m`

Таким образом мы доказали, что исходное сообщение, возведенное в степень `ed` и просто исходное сообщение имеют одинаковый остаток при делении на модуль `m`. Хочется спросить "Ну и что?". Но все эти вычисления происходят в *кольце по модулю* `m`. То есть, мы работаем не с "обычными" числами, мы работаем только с их остатками по модулю. И в этом "модульном мире" два числа равны, если они дают один и тот же остаток по модулю.

В обычной арифметике, чтобы вернуть исходное число, мы делаем обратную операцию: умножил на 3 - дели на 3, возвёл в квадрат - извлеки корень. Но в модульной арифметике нет деления как такового. Вместо этого мы находим такую операцию, которая по модулю вернёт нас в исходную точку. И именно это делает пара `ed`. В момент возведения в степень `d` происходит «восстановление», результат возвращает `n` по модулю `m`.

То есть, само сообщение - это тоже какой-то остаток, и мы не пытаемся узнать "настоящее" число - мы просто получаем тот же остаток, с которого начинали. Когда мы зашифровываем сообщение `n`, мы теряем всю информацию кроме остатка по модулю `m`.  Восстановить `n mod  m` - это и есть восстановить исходное сообщение.
### Ещё один пример

`p = 7`, `q = 13`
`m = 7 * 13 = 91`
`f = 6 * 12 = 72`
`e = 5`
`d = 1/5 mod 72 + 1`
`d = 145 / 5 = 29`

**Зашифруем сообщение** `6`:
`enc = 6^e mod m = 6^5 % 91 = 7776 % 91 = 41`

**Расшифруем**:
`dec = 41^29 % 91`

`d = 29 = 16 + 8 + 4 + 1`
`41^1 % 91 = 41`
`(41^2 = 1681) % 91 = 43`
`(41^4 = 43^2 = 1849) % 91 = 29`
`(41^8 = 29^2 = 841) % 91 = 22`
`(41^16 = 22^2 = 484) % 91 = 29`

`dec = (29 * 22 * 29 * 41) % 91 = 6`
