**REST** (Representational State Transfer, передача репрезентативного (самоописываемого) состояния) — архитектурный стиль взаимодействия компонентов распределённого приложения в сети. Это набор правил организации АПИ серверного приложения. Термин «REST» был введён Роем Филдингом, одним из создателей протокола «HTTP» в 2000 году. Существует шесть обязательных ограничений для построения распределённых REST-приложений. Накладываемые ограничения определяют работу сервера в том, как он может обрабатывать и отвечать на запросы клиентов. Действуя в рамках этих ограничений, система приобретает следующие свойства:

- Производительность — в том числе за счет использования кэша
- Масштабируемость
- Простота унифицированного интерфейса
- Открытость компонентов к возможным изменениям
- Прозрачность связей между компонентами системы для сервисных служб
- Переносимость компонентов системы путем перемещения программного кода вместе с данными
- Надёжность, устойчивость к отказам на уровне системы при наличии отказов отдельных компонентов
- Легкость внесения изменений
- Способность эволюционировать, приспосабливаясь к новым требованиям
### Требования

1. **Модель «клиент-сервер»** подразумевает разграничение потребностей интерфейсов клиента и сервера, повышает переносимость кода клиентского интерфейса на другие платформы, улучшает масштабируемость за счет упрощения серверной части.
2. **Отсутствие состояния** - в период между запросами клиента никакая информация о состоянии клиента на сервере не хранится. Все запросы от клиента должны быть составлены так, чтобы сервер получил всю необходимую информацию для выполнения запроса из них самих. Состояние сессии при этом сохраняется на стороне клиента.
3. **Кэширование** - клиенты, а также промежуточные узлы, могут выполнять кэширование ответов сервера. Ответы сервера, в свою очередь, должны иметь явное или неявное обозначение как кэшируемые или некэшируемые.
4. **Единообразие интерфейса** позволяют каждому из сервисов развиваться независимо. Имеется ввиду:
	- **Идентификация ресурсов**. Все ресурсы идентифицируются в запросах, например. Ресурсы концептуально отделены от представлений, которые возвращаются клиентам. Например, сервер может отсылать данные из базы данных в виде XML или JSON, ни один из которых не является типом хранения внутри сервера.
	- **Манипуляция ресурсами через представление**. Если клиент хранит представление ресурса, включая метаданные — он обладает достаточной информацией для модификации или удаления ресурса.
	- **Самоописываемые сообщения**. Каждое сообщение содержит достаточно информации, чтобы понять, каким образом его обрабатывать.
	- **Гипермедиа как средство изменения состояния приложения** ([[HATEOAS]]). Клиенты изменяют состояние системы только через действия, которые динамически определены в гипермедиа на сервере (к примеру, гиперссылки в гипертексте). Исключая простые точки входа в приложение, клиент не может предположить, что доступна какая-то операция над каким-то ресурсом, если не получил информацию об этом в предыдущих запросах к серверу.
5. **Слоеная архитектура** - клиент обычно не способен точно определить, взаимодействует он напрямую с сервером или же с промежуточным узлом, в связи с иерархической структурой. Применение промежуточных серверов способно повысить масштабируемость за счёт балансировки нагрузки и распределённого кэширования.
6. **Код по требованию** с сервера в виде апплетов или сценариев может позволить расширить функциональность клиента.

[Rest API guideline](https://restfulapi.net/resource-naming/)
