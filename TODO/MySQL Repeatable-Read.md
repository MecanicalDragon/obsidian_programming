### 1. Чем отличаются READ COMMITTED и REPEATABLE READ

- **READ COMMITTED**: каждая команда внутри транзакции видит только уже зафиксированные изменения других транзакций. Но разные запросы в рамках одной транзакции могут видеть _разные срезы данных_ (невозможна "грязная" читаемость, но возможны non-repeatable reads).
    
- **REPEATABLE READ**: все запросы в рамках одной транзакции видят один и тот же срез данных (snapshot), даже если параллельно что-то закоммитили.
    

---

### 2. Почему в MySQL сделали REPEATABLE READ дефолтным

- **MVCC реализация в InnoDB**  
    InnoDB реализует multi-version concurrency control так, что **стоимость REPEATABLE READ почти не отличается от READ COMMITTED**.  
    В READ COMMITTED нужно каждый раз брать новый snapshot при SELECT, а в REPEATABLE READ snapshot создаётся при старте транзакции и используется дальше. Это даже _дешевле_ для их архитектуры, потому что меньше лишних проверок версий строк.
    
- **Особенность "phantom reads"**  
    В ANSI SQL именно REPEATABLE READ _должен_ допускать фантомные чтения (новые строки, подходящие под WHERE). Но в MySQL под REPEATABLE READ ещё и **gap locks** используются, и фактически фантомы блокируются. То есть MySQL "усиленно" трактует этот уровень — он ближе к SERIALIZABLE, но дешевле.
    
- **Историческое решение**  
    Когда InnoDB стали дефолтным движком (с MySQL 5.5), Oracle (который тогда владел MySQL) оставил REPEATABLE READ дефолтным именно из-за вышеописанных особенностей MVCC и gap locking. Это снижало вероятность неожиданных "фантомных" багов в приложениях.


Как реализован рид коммитед в постгресе и оракле?