## Is SQL `IN` bad for performance?

First, `IN` clauses are generally internally rewritten by most databases to use the `OR` logical connective. So, `COL IN ('a','b','c')` will be rewritten to: `(COL = 'a') OR (COL = 'b') or (COL = 'c')`. The execution plan for both queries will likely be equivalent assuming that you have an index on `COL`.

Second, using either `IN` or `OR` with a variable number of arguments you force the database to re-parse the query and rebuild an execution plan each time the arguments change. Building the execution plan for a query can be an expensive step. Most databases cache the execution plans for the queries they run using the EXACT query text as a key. If you execute a similar query but with different argument values in the predicate - you will most likely cause the database to spend a significant amount of time parsing and building execution plans. This is why [bind variables are strongly recommended](http://decipherinfosys.wordpress.com/2007/08/29/bind-variables-usage-parameterized-queries-in-sql-server/) as a way to ensure optimal query performance.

Third, many databases have a limit on the complexity of queries. One of those limits is the number of logical connectives that can be included in the predicate. A few dozen values are unlikely to reach the built-in limit of the database, but if you expect to pass hundreds or thousands of values to the `IN` clause, it can definitely happen, and database will simply cancel the query request.

Fourth, queries that include `IN` and `OR` in the predicate cannot always be optimally rewritten in a parallel environment. There are various cases where parallel server optimization does not get applied - [MSDN has a decent introduction](http://msdn.microsoft.com/en-us/library/ms178065.aspx) - to optimizing queries for parallelism. Generally, though, queries that use the `UNION ALL` operator are trivially parallelizable in most databases - and are preferred to logical connectives (like `OR` and `IN`) when possible.
