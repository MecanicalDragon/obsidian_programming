**MVCC** stands for **Multi-Version Concurrency Control**. It ensures transaction isolation and implemented in all databases but in different ways.

## Postgres
#### Read Committed
В Postgres каждая строка имеет два скрытых системных поля: `xmin` и `xmax` — номера транзакций, создавшей эту версию строки и удалившей. Строка с этими полями называется *tuple*, и все версии одной и той же строки хранятся в той же самой таблице. Устаревшие версии собирает демон-процесс *VACUUM*.

Каждый запрос на старте получает свой *snapshot* - сортированный по времени (номеру) список активных транзакций на момет старта. При скане таблицы запрос отбирает *tuple*, сравнивая их `xmin` и `xmax` со списком активных транзакций, и таким образом видит только закоммиченные данные. Это дешево, потому что по факту это просто сравнение двух чисел - дешевле, чем *Read Committed* в исполнении MySQL.
#### Repeatable Read
Snapshot делается при `BEGIN` и живет все время транзакции, новые коммиты других транзакций просто игнорируются - это позволяет избежать [[ACID#^anomalies|фантомных чтений]] уже на этом уровне изоляции. А так как для каждого запроса проверка делается против старого *snapshot*, при апдейте изменённой другой транзакцией строки новая версия просто не будет видна, и Postgres бросит ошибку `could not serialize access due to concurrent update` (на *Read Committed* транзакция бы просто применила апдейт к новой версии строки). По данным чата GPT этот уровень в Postgres дороже *Read Committed* на 20–30% на интенсивной нагрузке.
#### Serializable
Это не «классический serializable с блокировками», а **SSI (Serializable Snapshot Isolation)**. Каждая транзакция работает в обычном *snapshot isolation* как при *Repeatable Read*, но Postgres строит граф «read-write» зависимостей между транзакциями. Если появляется опасный цикл, одну транзакцию откатывают, чтобы сохранить эквивалентность сериализуемому порядку.

Для предотвращения [[ACID#^anomalies|phantom reads]] и [[ACID#^anomalies2|write skew]] Postgres использует *predicate locks* - логические отметки вроде «транзакция читала данный диапазон строк, и её результат может измениться, если появятся новые строки». *Predicate lock* ставится на диапазон значений, участвующих в `WHERE` (индексный диапазон), и если другая транзакция вставляет/меняет tuple, подходящий под этот диапазон, возникает rw-конфликт.

Predicate locks не блокируют записи жёстко и не мешают параллельным транзакциям писать. Они хранятся в `pg_locks` и проверяются оптимизатором SSI. Если транзакции пересекаются опасным образом, Postgres бросает *serialization failure*: `ERROR: could not serialize access due to read/write dependencies among transactions`.

## MySQL
#### Read Committed
InnoDB хранит в таблице только последнюю (актуальную) версию строки. Старые версии попадают в *undo log* - связный список, который хранится в системных таблицах. Каждая строка в InnoDB содержит два скрытых служебных поля:
- `DB_TRX_ID` — идентификатор транзакции, которая изменила строку последней.
- `DB_ROLL_PTR` — указатель на undo-запись, которая позволяет восстановить предыдущую версию строки.
На старте транзакции InnoDB фиксирует её номер и список активных транзакций - это и есть её *snapshot*. InnoDB проверяет `DB_TRX_ID` у строки. Если эта строка изменилась после старта транзакции, движок лезет в *undo log* и откатывает изменения, пока не дойдёт до версии, которая была актуальна на момент создания *snapshot*. В результате транзакция читает свою консистентную версию данных без блокировок.
#### Repeatable Read
Схема такая же, как и в *Read Committed*. Разница только в том, что *snapshot* строится один раз при первом запросе в транзакции и используется до её конца. На обоих уровнях движок всё равно проверяет `trx_id` у строки и при необходимости идёт в *undo log*, поэтому разницы в накладных расходах почти нет, а *Repeatable Read* - дефолтный уровень изоляции в MySQL. На этом уровне при блокирующих чтениях  (`SELECЕ FOR UPDATE`, `LOCK IN SHARE MODE`, и т.п.) используются *gap locks*.
#### Serializable
Это «классический serializable с блокировками» - *gap locks*. *Gap lock* - это блокировка диапазона индексных значений (включая незанятые значениями "дыры" - gaps): если одна транзакция выбирает для апдейта `WHERE id BETWEEN 100 AND 200`, это блокирует и вставки новых строк в этот диапазон, чтобы предотвратить фантомы, и выборку для апдейта. Из-за этого параллелизм снижается, но откатов транзакций почти нет (только deadlock-и). На этом уровне *gap locks* используются даже для простых `SELECT`, а сами `SELECT` запросы ведут себя как `SELECT … LOCK IN SHARE MODE`.

## Oracle
#### Read Committed
Oracle хранит в самой таблице только текущую версию строки. Старые версии перемещаются в *undo segments* (*rollback segments*). При начале каждого SQL-запроса строится *snapshot* - список транзакций, закоммиченных к этому моменту. Для каждой строки если изменившая её транзакция уже сделала коммит, строка видима, если нет, Oracle достает старую версию из *undo*.
#### Serializable
Snapshot делается при старте транзакции (`BEGIN`) и используется до ее завершения. Если транзакции конфликтуют, Oracle при коммите выдаёт ошибку `ORA-08177: can't serialize access for this transaction`.

*Repeatable Read* по факту использует ту же самую *Serializable* изоляцию, Oracle честно пишет, что разницы между ними нет.
