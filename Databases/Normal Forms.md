**Нормальные формы** — это набор правил для структурирования данных в реляционных базах, которые помогают:
- **избежать избыточности** (дублирования одних и тех же данных),
- **минимизировать аномалии** при вставке, обновлении и удалении данных,
- **улучшить целостность**.
Они возникли ещё в 1970-х, когда Эдгар Кодд формализовал принципы реляционной модели. На практике в большинстве случаев зачастую имеет смысл нормализовать данные до *BCNF*, всё, что выше - редкие кейсы.

**NF1**. Переменная отношения находится в первой нормальной форме тогда и только тогда, когда в любом допустимом значении этой переменной каждый кортеж отношения содержит только одно значение для каждого из атрибутов.

**NF2**. Переменная отношения находится во второй нормальной форме тогда и только тогда, когда она находится в первой нормальной форме и каждый неключевой атрибут неприводимо зависит от (каждого) её потенциального ключа

*Неприводимость* означает, что в составе потенциального ключа отсутствует меньшее подмножество атрибутов, от которого можно также вывести данную функциональную зависимость.

*Неключевой атрибут отношения R* — это атрибут, который не принадлежит ни одному из потенциальных ключей R.

**NF3**. Переменная отношения R находится в 3NF тогда и только тогда, когда R находится во второй нормальной форме, и ни один неключевой атрибут R не находится в транзитивной функциональной зависимости от потенциального ключа R.

В отношении `(Сотрудник, Отдел, Телефон)` существуют следующие функциональные зависимости: `Сотрудник → Отдел`, `Отдел → Телефон`, `Сотрудник → Телефон`.

Переменная отношения R находится во второй нормальной форме, поскольку каждый атрибут имеет неприводимую функциональную зависимость от потенциального ключа `Сотрудник`. Однако, зависимость `Сотрудник → Телефон` является транзитивной, так как телефон зависит не напрямую от сотрудника, а от его отдела.

**BCNF**. Переменная отношения находится в BCNF тогда и только тогда, когда каждая её *нетривиальная* и *неприводимая слева* *функциональная зависимость* имеет в качестве своего *детерминанта* некоторый *потенциальный ключ*. Менее формально, переменная отношения находится в BCNF тогда и только тогда, когда детерминанты всех её функциональных зависимостей являются потенциальными ключами, то есть, нет зависимости между атрибутами, входящими в состав ключей (*prime attributes*). Для определения BCNF следует понимать понятие функциональной зависимости атрибутов отношения.

*Функциональная зависимость* - это такая зависимость между произвольными подмножествами X, Y множества атрибутов переменной отношения R, когда для любого допустимого значения R, если два кортежа R совпадают по значению X, они также совпадают и по значению Y. Другими словами, Y однозначно определяется X. Подмножество X в таком случае называют *детерминантом*, а Y — *зависимой частью*. Обозначается `X → Y`.

*Функциональная зависимость тривиальна* тогда и только тогда, когда её правая (зависимая) часть является подмножеством её левой части, то есть, входит в состав детермината. Тривиальные зависимости всегда выполняются по определению — они не несут полезной информации.

*Функциональная зависимость называется неприводимой слева*, если ни один атрибут не может быть опущен из её детерминанта без нарушения зависимости (иными словами, детерминант *не избыточен*).

Ситуация, когда отношение будет находиться в 3NF, но не в BCNF, возникает, когда какой-то из ключевых атрибутов (*prime attribute*) зависит от не-суперключа. На практике такие отношения встречаются достаточно редко, для всех прочих отношений 3NF и BCNF эквивалентны.

*Суперключ* — это любой набор атрибутов, который однозначно определяет каждую строку в таблице. Никакие две строки не могут иметь одинаковые значения во всех атрибутах суперключа.

*Потенциальный ключ (candidate key)* — это суперключ, у которого нет лишних атрибутов.  Он — минимальный: если удалить из него любой атрибут, он перестанет быть уникальным.
Каждый потенциальный ключ — это суперключ, но не каждый суперключ — потенциальный, потому что он может быть избыточным.

Для примера возьмем отношение `(student_id, course_id, instructor)`. Его функциональными зависимости:
- `(student_id, course_id) → instructor` — очевидно, преподаватель определён для конкретного студента и курса. Курс + студент - потенциальный ключ, он уникально определяет строку.
- `instructor → course_id` — каждый преподаватель ведёт только один курс, но преподаватель - не суперключ.

**NF4**. Переменная отношения R находится в четвёртой нормальной форме, если она находится в НФБК и любая нетривиальная многозначная зависимость в нём имеет в качестве детерминанта суперключ.

*Многозначная зависимость* – такая зависимость в отношении R (A, B, C), при которой множество значений C, соответствующее паре значений A и B, зависит только от A и не зависит от B. Обозначается как `X ↠ Y`.

Четвёртая нормальная форма нужна, когда у одной сущности может быть несколько независимых наборов значений (студент -> курсы, хобби), и ты не хочешь хранить все возможные комбинации между ними (их декартово произведение). Это логическое продолжение BCNF, но с фокусом не на функциях (`X → Y`), а на множественности (`X ↠ Y`).

**NF5**. Отношение находится в пятой нормальной форме тогда и только тогда, когда каждая нетривиальная зависимость в нём определяется потенциальным ключом (ключами) этого отношения. То есть, каждое из подмножеств множества атрибутов в отношении является суперключом отношения и включает некоторый потенциальный ключ этого отношения.

Более простыми словами, отношение находится в 5NF, если любое его представление несколькими отношениями-проекциями можно собрать обратно в исходной отношние операцией естественного соединения (natural join) без потери информации, и при этом все соединения необходимы.

5NF предотвращает ситуации, когда разбиение таблицы по частям работает нормально, но восстановление исходной таблицы через JOIN приводит к лишним строкам (аномалиям). Например, отношение `Contracts(supplier, part, project)` - поставщик может поставлять определённые детали для определённых проектов. Разбиение по проекциям даёт три отдельные таблицы: `(supplier, part)`, `(supplier, project)`, `(part, project)` - но даже если каждая пара существует, не факт, что тройка допустима. 5NF требует: не дели дальше, если потом нельзя однозначно восстановить.

**NF6**. Переменная отношения находится в шестой нормальной форме тогда и только тогда, когда она не содержит никаких нетривиальных соединительных зависимостей, кроме тех, которые обусловлены ключами (в том числе, зависимости от времени или других внешних условий).

Эта форма крайне редко оправдана, но может иметь смысл, например, в таблицах с историями изменений. Возьмем отношение `employee_id, salary, address, valid_from, valid_to`: salary и address могут изменяться независимо во времени. Чтобы это выразить строго и корректно, данные нужно разнести:
- `employee_id, salary, valid_from, valid_to`
- `employee_id, address, valid_from, valid_to`
Так достигается 6NF — данные хранятся как независимые элементарные факты, и можно отслеживать отдельную историю изменений каждого поля. Этот подход применяется в колоночных БД, хранящих поля отношений отдельными версионируемыми колонками.

**DKNF**. Переменная отношения находится в ДКНФ тогда и только тогда, когда каждое наложенное на неё ограничение является логическим следствием ограничений доменов и ограничений ключей, наложенных на данную переменную отношения. Это идеализированная цель нормализации — «чистейшая» форма. Любая переменная отношения, находящаяся в ДКНФ, обязательно находится в 5НФ. Однако не любую переменную отношения можно привести к ДКНФ.

*Ограничение домена* – ограничение, предписывающее использовать для определённого атрибута значения только из некоторого заданного домена. Ограничение по своей сути является заданием перечня (или логического эквивалента перечня) допустимых значений типа и объявлением о том, что указанный атрибут имеет данный тип. (например, возраст сотрудника должен быть от 18 до 55)

*Ограничение ключа* – ограничение, утверждающее, что некоторый атрибут или комбинация атрибутов является потенциальным ключом отношения.

Цель DKNF - обеспечить, чтобы все ограничения целостности в таблице можно было выразить только через домены и ключи, то есть стандартными средствами СУБД, без триггеров, проверок и т. п.. В современных системах DKNF практически не используется, потому что многие ограничения всё равно проще реализовать вне базы (в логике приложения или бизнес-слое).
