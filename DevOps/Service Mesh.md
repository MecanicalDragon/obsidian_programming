**Service Mesh** — подход, смысл которого в том, что когда у нас есть какая-то распределённая система, которая работает и взаимодействует по сети, мы добавляем дополнительный сетевой уровень, который позволяет нам добавлять какие-то возможности, любую логику в межсервисное взаимодействие сетевых узлов. Например, когда делается запрос в сервисе через Linkerd, очень упрощённая последовательность событий выглядит следующим образом:
- Linkerd применяет динамические правила маршрутизации, определяя, к какому сервису предназначен запрос. Запрос должен быть передан сервису в production или staging? Сервису в локальном дата-центре или в облаке? Самой последней версии сервиса, которая была протестирована, или более старой версии, проверенной в production? Все эти правила маршрутизации конфигурируются динамически, могут применяться глобально или для выбранных срезов трафика.
- Найдя нужного получателя, Linkerd запрашивает подходящий пул экземпляров у службы обнаружения соответствующей конечной точки (их может быть несколько). Если эта информация расходится с тем, что Linkerd видит на практике, он принимает решение, какому источнику информации доверять.
- Linkerd выбирает экземпляр, который с большей вероятностью вернёт быстрый ответ, основываясь на ряде факторов (включая задержку, зафиксированную для недавних запросов).
- Linkerd пытается отправить запрос экземпляру, записывая результат операции (задержку и тип ответа).
- Если экземпляр упал, не отвечает или не может обработать запрос, Linkerd пробует этот запрос на другом экземпляре (только в том случае, если знает, что запрос является идемпотентным).
- Если экземпляр постоянно возвращает ошибки, Linkerd убирает его из пула балансировки нагрузки и будет периодически проверять его в дальнейшем (экземпляр может испытывать кратковременный сбой).
- Если дедлайн для запроса достигнут, Linkerd превентивно возвращает ошибку запроса, а не добавляет нагрузку с повторными попытками его выполнения.
- Linkerd учитывает каждый аспект описанного выше поведения в виде метрик и распределённого отслеживания — все эти данные отправляются в централизованную систему метрик.

![[service_mesh.png]]

Функциональность userproxy довольно богатая, но ее можно разделить на три класса:
- **Функции, связанные с мониторингом**: агрегация показателей успешности, задержек и объёмов запросов для каждого сервиса или отдельных направлений; построение топологических карт сервисов и т.д.
- **Функции, связанные с надёжностью**: повторные запросы, таймауты, канареечный подход (разделение/перенаправление трафика) и т.д.
- **Функции, связанные с безопасностью**: mutual TLS, контроль доступа и т.д.

|                  | Наблюдаемость                           | Надежность                                       | Безопасность                                     |
| ---------------- | --------------------------------------- | ------------------------------------------------ | ------------------------------------------------ |
| **Service Mesh** | Статистика успешности запросов сервиса  | Повтор запросов                                  | mutual TLS между сервисами                       |
| **Платформа**    | Агрегация логов                         | Репликация данных                                | Шифрование неактивных данных                     |
| **Приложение**   | Анализ использования внутренних функций | Обработка сбоя в случае падения всего компонента | Обеспечение доступа юзеров только к своим данным |
**Плюсы:**
- независимость от платформы (языка микросервиса)
- единая конфигурация, функционал и представление данных
- конфигурация может изменяться динамически
- отделение бизнес-логики от технической функциональности

**Минусы:**
- сложность конфигурации и внедрения
- увеличение времени вызова
- увеличение потребляемых ресурсов
